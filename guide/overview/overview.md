# TDCC 구성

# TDCC의 주요 요소

TDCC의 핵심 가치인 중층적, 고객 중심적, 동적을 만족시키기 위해 프레임워크는 아래와 같은 주요 요소들을 가지게 됩니다.

### 중층적

프레임워크는 고객의 근원적 문제와 이를 풀기 위해 선행적으로 해결되어야 하는 세부문제들, 그리고 고객이 제품을 이용하는 이유와 패턴에 대한 내용을 담고 있어야 합니다. 이를 나눠서 각각 자세히 설명하자면 아래와 같습니다.

| **요소** | **설명** |
| --- | --- |
| 문제 | 제품을 통해 해결하고자 하는 가장 핵심적인 문제를 의미합니다. |
| 세부문제 | 핵심적인 문제를 해결하기 위해 선행적으로 해결되어야 하는 세부 문제들입니다. |
| 세부문제 우선순위 | 각 세부 문제 중 핵심적인 문제에 더 강한 영향을 주는 정도를 기준으로 세부 문제간 우선순위를 정하는 것입니다. |
| 멘탈모델 | 세부 문제에 대해 고객은 어떻게 생각하고 어떻게 행동할까에 대한 생각을 담은 항목입니다. |

이 요소들은 순서에 따라 정의, 기술되어야 합니다. 이는 위 요소들이 문제 → 세부문제 → 멘탈모델의 순서로 기술되어야 한다는 것을 의미합니다. 이렇게 순서를 가지는 이유는 문제가 있어야 이를 세부문제로 나눌 수 있고, 문제가 있어야 문제를 풀기 위해 고객에 대한 이론을 세우는 것이 의미가 있기 때문입니다. 하나의 과정만 누락되더라도 프레임워크의 효용과 프레임워크가 주는 가치는 크게 훼손될 수 있습니다.

또한, 위 요소들은 자유롭게 확장되며 고객의 문제를 다양한 관점에서, 여러가지 항목들을 통해 풀어나갈 수 있게 합니다. 예를 들어, 문제에는 이 문제를 풀어내기 위해 선결되어야 하는 세부 문제가 있습니다. 세부 문제는 하나만 있을 수도 있지만, 문제를 풀어내기 위해 두 개 이상의 선행되는 세부 문제를 풀어내야할 수도 있습니다. 하나의 문제 아래에 몇 개의 세부문제가 있을 수 있고, 그 세부문제 아래에 또 복수의 세부문제가 있을 수 있는 것이 확장성이 의미하는 것입니다.

### 고객 중심적

기술한 문제와 고객에 대한 멘탈 모델을 토대로 고객 중심의 가설과 실행안이 체계적으로 나올 수 있어야 합니다. 이는 아래와 같은 요소들로 이루어집니다.

| **요소** | **설명** |
| --- | --- |
| 가설 | 어떠한 기능이나 제품을 제공한다면 고객의 행동은 이렇게 변화할 것이다라는 생각을 담은 것입니다. 이는 멘탈모델에 기초하게 됩니다. |
| 실행안 | 가설을 구체적으로 어떻게 실행하여 기능을 개발하고 제품을 출시할지에 대한 안입니다. 가설을 토대로 해결안이 나오게 됩니다. |

가설과 해결안 모두 중층적으로 기술한 문제-세부문제-멘탈모델과 마찬가지로 순서에 따라 만들어져야 합니다. 멘탈모델 없이 나온 가설과 좋은 가설 없이 나온 해결안은 고객 중심적으로 문제를 해결할 수 없기 때문입니다. 그리고 마찬가지로, 하나의 멘탈모델 아래에서 여러 가지 가설이 있을 수 있으며 가설을 토대로 다수의 실행안이 나올 수 있습니다.

### 동적

고객을 위한 모바일/웹 제품의 완성에 이르기 위해서는 제품의 연속적인 출시와 실행과정 속 위에서 이야기한 요소들이 지속적으로 발전하는 과정이 필수적입니다. 이러한 과정은 가설을 토대로 한 실행안을 분석하고 그에 대한 피드백 없이는 진행될 수 없습니다.

| **요소** | **설명** |
| --- | --- |
| 분석 | 해결안이 의도대로 잘 진행되었는지를 확인하는 부분입니다. |
| 피드백 | 분석 내용을 토대로 위의 항목들 중 개선할 부분이나 계속 발전시켜나갈 부분을 찾아나가는 것을 담은 항목입니다. |

최종적인 피드백을 토대로 고객과 제품에 대한 팀의 이해도가 높아지는 과정이 반복, 지속되며 각 요소들이 지속적으로 발전, 결과적으로 고객의 문제를 해결해줄 수 있는 높은 수준의 제품을 고객에게 전달할 수 있게 되는 것이 프레임워크가 지향하고 있는 바입니다. 

# TDCC의 구조

![스크린샷 2024-10-21 오전 1.21.47.png](TDCC%20%E1%84%80%E1%85%AE%E1%84%89%E1%85%A5%E1%86%BC%2081c06c8ab05c4cd9837d2e2d2f31eba6/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2024-10-21_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%258C%25E1%2585%25A5%25E1%2586%25AB_1.21.47.png)

프레임워크의 구조는 프레임워크의 핵심가치와 주요 요소에 따라 구성됩니다. 우선 주요 요소들을 담아내기 위해 Object라는 기본 단위를 가지게 됩니다. Object는 Palantir의 Ontology에서 참고한 개념으로, 마치 블록과 마찬가지로 이러한 Object라는 조각이 모이고 연결되어 프레임워크를 구성하게 됩니다. Object는 각각의 요소들을 담을 수 있으며 각 요소가 가지는 고유한 순서에 따라 논리적으로 연결되도록 만들어졌습니다. 이러한 순서에 따른 연결을 보다 체계적으로 표현하기 위해 Level이라는 개념을 도입하여 유사한 성격을 가지는 Object간의 연결을 그룹화하여 각각 Conception Level-Execution Level-Feedback Level로 나누었습니다. 또한, 각 Object에는 여러 Object들이 하위의, 혹은 상위의 Object로 연결될 수 있도록 하였습니다. 마지막으로 이 Object들이 동적으로 발전할 수 있도록 EIP([Ethereum Improvement Proposals](https://eips.ethereum.org/))에서 착안한 Proposal이라는 개념을 가져왔고, Layer라는 개념을 통해 Proposal을 통해 제거되거나 수정된 Object의 히스토리를 쉽게 관찰하고 미래의 더 좋은 제품을 위해 참고할 수 있도록 하였습니다. 이는 Airbnb의 [Scaling Knowledge](https://medium.com/airbnb-engineering/scaling-knowledge-at-airbnb-875d73eff091)를 참고한 결과입니다.

## Object

![스크린샷 2024-10-14 오전 1.26.20.png](TDCC%20%E1%84%80%E1%85%AE%E1%84%89%E1%85%A5%E1%86%BC%2081c06c8ab05c4cd9837d2e2d2f31eba6/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2024-10-14_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%258C%25E1%2585%25A5%25E1%2586%25AB_1.26.20.png)

Object는 TDCC를 구성하는 기본구조입니다. 이 Object가 규칙에 따라 조합, 배열, 연결되며 프레임워크(=Layer)를 구성하게 됩니다. Object는 아래와 같은 Property를 가지게 됩니다.

- Type: 프레임워크의 구성요소인 문제/세부문제/이론/가설/실행안/평가/피드백 중 하나를 타입으로 가집니다. 이 타입은 하나만 가질 수 있습니다.
- Relationship: 해당 오브젝트가 다른 오브젝트와 어떻게 연결되고 있는지를 알려주는 프로퍼티입니다.
    - Parent: 해당 오브젝트를 자식 오브젝트로 가지고 있는 부모 오브젝트입니다. 오브젝트 타입이 문제일 경우 Null입니다.
    - Children: 해당 오브젝트를 부모 오브젝트로 가지고 있는 자식 오브젝트입니다. 오브젝트 타입이 피드백일 경우 Null입니다.
- Content: 해당 오브젝트의 자세한 내용을 의미합니다. 이 콘텐츠의 내용 및 포맷은 오브젝트 타입에 따라 달라집니다
    - 문제 콘텐츠
    - 세부문제 콘텐츠
    - 이론 콘텐츠
    - 가설 콘텐츠
    - 실행안 콘텐츠
    - 분석 콘텐츠
    - 피드백 콘텐츠

## Level과 Building Rules

### 전체 구조

![스크린샷 2024-09-24 오전 2.30.43.png](TDCC%20%E1%84%80%E1%85%AE%E1%84%89%E1%85%A5%E1%86%BC%2081c06c8ab05c4cd9837d2e2d2f31eba6/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2024-09-24_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%258C%25E1%2585%25A5%25E1%2586%25AB_2.30.43.png)

- 프레임워크의 전체 구조는 기본적으로 위와 같습니다. 이 구조 내에서 유사점이 있는 부분들을 묶어서 Level이라 일컫습니다.
- 각각의 Level은 문제을 위한 기초 내용을 구상하는 Conception Level, 실행안을 내어놓는 Execution Level, 피드백을 목적으로 하는 Feedback Level로 나뉩니다.

### Conception Level

![스크린샷 2024-10-14 오전 1.12.03.png](TDCC%20%E1%84%80%E1%85%AE%E1%84%89%E1%85%A5%E1%86%BC%2081c06c8ab05c4cd9837d2e2d2f31eba6/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2024-10-14_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%258C%25E1%2585%25A5%25E1%2586%25AB_1.12.03.png)

- 팀이 풀어야 할 문제를 정의하고, 세분화하여 팀이 풀어야 할 근원적 문제와 해결해야 할 문제를 확립한 후 고객에 대한 멘탈모델을 세워보는 부분입니다.
- 문제, 세부문제 및 멘탈모델 타입의 Object들로 구성됩니다.
- Building Rules
    - 세부문제: 세부문제 아래에는 또 다른 세부문제가 연결될 수 있습니다. 예를 들어 고객이 상품을 잘 발견하도록 한다라는 세부문제에는 검색을 통해 상품을 잘 발견하게 한다, 카테고리를 통해 상품을 잘 발견하게 한다라는 세부문제가 연결될 수 있습니다.
    - 멘탈모델: 멘탈모델 아래에는 다른 멘탈모델이 연결될 수 없습니다. 하지만 하나의 멘탈모델이 여러 세부문제를 Parent로 두며 여러 세부문제 해결을 위한 공통 기반이 될 수도 있습니다.

### Execution Level

![스크린샷 2024-10-14 오전 1.12.24.png](TDCC%20%E1%84%80%E1%85%AE%E1%84%89%E1%85%A5%E1%86%BC%2081c06c8ab05c4cd9837d2e2d2f31eba6/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2024-10-14_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%258C%25E1%2585%25A5%25E1%2586%25AB_1.12.24.png)

- 문제를 풀어내기 위해 Conception Level에서 정의한 내용에 기초하여 가설과 실행안을 내어놓는 부분입니다.
- 가설, 실행안 타입의 Object들로 구성됩니다.
- Building Rules
    - 가설: 이론 아래에 여러 가지 가설이 연결될 수 있습니다. 가설 아래에는 가설이 연결될 수 없습니다.
    - 실행안: 하나의 가설 아래에 여러 가지 실행안이 연결될 수 있습니다.

### Feedback Level

![스크린샷 2024-10-14 오전 1.14.27.png](TDCC%20%E1%84%80%E1%85%AE%E1%84%89%E1%85%A5%E1%86%BC%2081c06c8ab05c4cd9837d2e2d2f31eba6/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2024-10-14_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%258C%25E1%2585%25A5%25E1%2586%25AB_1.14.27.png)

- 진행한 실행안을 평가하고 Conception, Execution Level을 발전시키기 위한 방향과 안을 내어놓는 부분입니다.
- 분석, 피드백 타입의 Object들로 구성됩니다.
- Building Rules
    - 분석: 하나의 실행안에는 하나의 분석만 연결될 수 있습니다.
    - 피드백: 피드백은 여러 실행안, 혹은 하나의 실행안에 연결될 수 있습니다. 여러 평가를 토대로 피드백을 만들 수도, 하나의 평가를 토대로 피드백이 나올 수도 있기 때문입니다.

## Layer

![스크린샷 2024-10-14 오전 1.40.38.png](TDCC%20%E1%84%80%E1%85%AE%E1%84%89%E1%85%A5%E1%86%BC%2081c06c8ab05c4cd9837d2e2d2f31eba6/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2024-10-14_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%258C%25E1%2585%25A5%25E1%2586%25AB_1.40.38.png)

Layer는 Archived Layer와 Active Layer로 구성됩니다. 여기서 Archived Layer는 유효하지 않은 것으로 판명되어 Proposal을 통해 Archive된 문제, 이론, 가설, 실행안, 분석, 피드백 타입 Object들을 담는 곳입니다. 반대로, Active Layer는 유효하며 제품 개발에 중요한 Object들을 담고 있는 곳입니다. Layer가 나뉘어져 있는 이유는 제품 개선을 위해 봐야 할 Object들을 한눈에 보여주는 동시에, 유효하지는 않은 것으로 판명났지만, 과거의 생각과 실행안들을 담고 있는 Object들을 잘 저장하여 차후의 아이디에이션이나 더 좋은 피드백 프로세스에 활용할 수 있도록 하기 위함입니다.

### Active Layer

Active Layer는 현재 Active한 상태에 있는 Object들을 담고 있는 Layer입니다. 각각의 Object들은 현재 상태에서 유효하거나, 실행 단계에 있는 것들이며 이후 Proposal에 따라 개선될수도, 삭제되어 Archived Layer로 갈 수도, 지속적으로 유효한 것으로 판명되어 존치될 수도 있습니다. Active Layer는 아래와 같은 특성을 가지고 있습니다.

- 일반적으로 Parent Object가 삭제되거나 개선되면, 이에 따라 Children Object도 함께 바뀌게 됩니다.
- 실행안과 분석, 피드백 Object는 제품 배포가 진행되고 분석을 하게 되며 매번 새로운 것이 나올 수 있기에 매 Sprint, 혹은 Cadence마다 변화하는 것이 일반적입니다. 이들이 Active Layer에 있을 때, 이들을 보통 실행 단계에 있다고 표현합니다.
- 문제와 세부문제, 멘탈모델과 가설 Object는 여러 번의 실행과 분석을 통해 이 것이 맞는지 검증하는 과정이 선행되어야 하기에 상대적으로 몇 번, 혹은 그 이상의 Sprint, 혹은 Cadence가 진행되며 변화하는 것이 일반적입니다. 이들이 Active Layer에 있을 때, 이들을 보통 유효하다고 표현합니다.

### Archived Layer

Archived Layer는 팀의 고민과 아이디어, 그리고 이에 기반한 실행과 그 결과들을 담고 있는 Object들을 저장해놓는 Layer입니다. 유효하지 않은 것으로 판명되거나 실행과 분석, 피드백이 완료되어 그 역할을 다한 Object들을 Archived Layer에 저장해놓은 이유는 Knowledge Scalability를 위해서입니다. 이는 Airbnb에서 공유한 동명의 글(Scaling Knowledge at Airbnb)에서 기인한 아이디어이며 지식을 체계적으로, Scalable하게 저장하여 과거의 Object들을 재생산가능하고, 소비할 수 있으며, 발견이 용이하도록 만들기 위한 개념을 가지고 있습니다. Archived Layer는 이러한 개념을 프레임워크에서 실현하기 위한 구조입니다.

## Proposal

Proposal은 연속성을 위한 부분입니다. 단순히 위의 Level에 따라 문제를 정의하고, 실행안을 도출하며, 피드백을 주는 과정이 한 번 진행되고 끝나는 것이 아닌, 계속해서 진행되는 동시에 피드백을 토대로 Object들이 동적으로 발전하고 변화해나갈 수 있도록 하기 위해 Proposal이 존재합니다. Proposal의 형태는 [EIP](https://eips.ethereum.org/EIPS/eip-1)에서 영감을 받은 것으로 Layer와 그 안의 Object들을 발전시키기 위한 제안을 담고 있습니다. 이러한 Proposal이 반복되며 Layer는 더 좋은 문제, 멘탈모델, 그리고 가설 타입의 Object를 담게 됩니다. Proposal은 피드백을 기반으로 진행됩니다.

### Proposal의 구성요소

- 종류: 어떤 Level(Conception, Execution, Feedback)에 대한 피드백인지에 대해 적시합니다.
- 대상: 실행안 / 가설 / 이론 / 세부문제 / 문제 타입의 Object입니다. 여러개일 수도, 한 개일 수도 있습니다.
- 조치: 개선 / 삭제 / 존치 중 조치할 방향을 이야기합니다.
- 동기 및 근거: 타입에서 설정한 의견이 나온 이유를 설명합니다.
- 사양: 개선한다면 어떻게 개선할 것인지, 삭제한다면 그 후 어떤 것으로 대체할지에 대해 기술합니다.

### Proposal의 진행

![스크린샷 2024-09-24 오전 2.38.45.png](TDCC%20%E1%84%80%E1%85%AE%E1%84%89%E1%85%A5%E1%86%BC%2081c06c8ab05c4cd9837d2e2d2f31eba6/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2024-09-24_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%258C%25E1%2585%25A5%25E1%2586%25AB_2.38.45.png)

Proposal은 아래와 같은 단계로 진행됩니다. 

1. Draft: 피드백 Object의 내용을 토대로 작성된 Proposal 초안입니다. 아직은 Draft 단계로 적용되려면 이후 단계를 거쳐야 합니다.
2. Review: Draft에 대한 리뷰를 진행합니다. 종류와 대상, 조치 등에 대해 모두가 동의하는지, 동기 및 근거나 사양에 대해 팀원이 공감하는지를 확인합니다. 일반적으로 회고 시점에 진행됩니다.
    1. Stagnant: Draft가 작성되었으나 Review나 Last Call에서 Consensus에 이르지 못한 Proposal이 가게 되는 단계입니다. 이후 논의를 거쳐 다시 Draft단계로 돌아가 리뷰를 받아 다음 과정으로 나아가거나 영구히 삭제될 수 있습니다.
3. Last Call: 최종적으로 해당 Proposal을 수용하여 Object들의 소속 Layer를 변경시키거나 새로운 Object를 생성할지, 어떤 Object를 삭제할지 등을 결정하는 과정입니다. 회고 시점, 혹은 회고 이후에 진행될 수 있습니다. 
4. Final: Last Call에서 적용으로 결론이 난 Proposal의 내용에 따라 프레임워크를 업데이트하는 단계입니다.